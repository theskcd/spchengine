Lex 0:00:00

The following is a conversation with John Carmack, widely considered to be one of the greatest programmers ever. He was the co-founder of id Software and the lead programmer on several games that revolutionized the technology, the experience, and the role of gaming in our society, including Commander Keen, Wolfenstein 3D, Doom, and Quake. He spent many years as the CTO of Oculus VR, helping to create portals into virtual worlds and to define the technological path to the metaverse and meta. And now he has been shifting some of his attention to the problem of artificial general intelligence. This was the longest conversation on this podcast at over five hours, and still I could talk to John many, many more times, and we hope to do just that. And now a quick few second mention of each sponsor. Check them out in the description. It's the best way to support this podcast. We got Inside Tracker for longevity, Indeed for hiring, Blinkist for nonfiction, 8sleep for napping, and Athletic Greens for performance. Choose wisely, my friends. And now onto the full ad reads. As always, no ads in the middle. I try to make this interesting, but if you skip them, please still check out our sponsors. I enjoy their stuff. Maybe you will, too. This show is brought to you by Inside Tracker, a service I use to track biological data from my body to make decisions about my life. By the way, I'm not one of those people that tries to optimize every single aspect of my life. There are certain personalities that are attracted to tech are also attracted to this kind of rigorous optimization with like a spreadsheet tracking every single aspects of your life. And you have this notion that it's possible to live an optimal life. Optimal defined by some kind of metrics that are measurable. You know, it's like a, you know, you have a smart home that have lights automatically turn on. In the same way, have like a smart body that can control every single aspect of your life, including relationships, diet, exercise, productivity, all that kind of stuff. I am not one of those people. I barely make plans. I don't really want to ruin the romance of life by over planning, over strategizing, over controlling every single aspect of my life. I do try to have discipline as part of my life because it is true. I think that Jocko talks about, you know, discipline is freedom. When you have this kind of base of daily activity, you can improvise on top of that. You can break the rules, but you need to have the rules in order to break them. So, you know, Insight Tracker collects data from your body that can help you make decisions about your body, but it doesn't force you to have a kind of very strict, very perfect life. You should still live life. You should still do stupid stuff, but you should have the option to understand what is going on inside your body and how to improve various aspects that you might want to improve. Get special savings for a limited time when you go to insighttracker.com slash Lex. This show is also brought to you by Indeed, a hiring website. There's very few things as important in this too short life of ours than the people we surround ourselves with. That means family, friends, maybe even strangers you meet up at a bar and get lost in the conversations with for many hours, and they become fast friends. That's how life works. Anyway, the people you really spend a lot of time with in your life is the people you work with. I think for many of us, work is not just a source of money. It's also a source of meaning, fulfillment. And so whether you're an employee or an employer, building a team that's worth working together with is one of the most important things you can do, not just for the productivity and success of the company, but just for happiness, fulfillment. And so you should use the best tools available for that kind of thing. Indeed is one such tool. It has a special offer, only available for a limited time. Check them out at indeed.com slash Lex. This show is also brought to you by Blinkist, my favorite app for learning new things. It has some of the greatest nonfiction books ever written on there, summaries of them, and allows you to either pick the books you wanna read in the future, or remind yourself of the key insights about the books you've already read. Reading a full-length book is a journey that has two benefits. One is you pick up really powerful insights, and that's something that Blinkist can help you with. It's better than any place I've ever seen in terms of distilling the key insights. But the second reason, at least I enjoy reading, even nonfiction, is that it takes you on a journey, almost like traveling to another place in time, and you get to really sit there in that, and you get to imagine yourself in that, and you get to imagine what would I do in those different situations, whether it's some of the darkest or some of the most beautiful aspects of life, of history, and in those cases, there's a lot of power to reading the full book. But time is limited, and so you should pick carefully the books that you read fully. You only get so many books in your whole life. It's kind of sad, just like you get only so many friends, so many trips you take abroad, or to a different part of town, a different part of the state, a different part of the country. You only get a limited number of books, so choose them carefully. You can get savings at blinkist.com slash Lex. This episode is also brought to you by Eight Sleep, and it's pod-prone mattress. It controls temperature with an app. It has a bunch of sensors, and it can cool you down to as low as 55 degrees on each side of the bed separately. It doesn't have to be a war about temperature. It can be a compromise, or it actually doesn't need to be a compromise. You can live your own sovereign selves and define the temperature that defines your land that belongs to you if you sleep with a partner. I just have to say that I think one of the most pleasant experiences of life is a short nap on a cool bed with a warm blanket when all the concerns of life disappear for just a few minutes, and you go into that dreamland, wherever that is, wherever, whenever that is, probably a place we go to after we die. You get to go there for a brief moment and see what it's like, and then return refreshed, renewed, to take on the rest of the day. That's a source of happiness for me. Check them out for special savings at asleep.com slash Lex. This show is also brought to you by Athletic Greens and the 8G1 Drink, which is a all-in-one daily drink to support better health and peak performance. It replaced the multivitamins for me and went far beyond that with 75 vitamins and minerals. It's the first thing I drink every day. I drink it twice a day now. So this conversation is with John Carmack, right? And he famously just ate a pizza a day with a bunch of Diet Coke. He still drinks so much Diet Coke. And I certainly have quirks like that. Not pizza, necessarily, but I do enjoy Diet Coke, for sure. There's been periods in my life where it would just be an embarrassing number of Diet Cokes, or rather, Coke Zeros. Those are, I believe, a little bit more delicious. Or Pepsi Max, that's probably my favorite. Anyway, there's arguably not much nutritional value to a Pepsi Max or a Diet Coke, so you should fill in the nutritional gaps for yourself with vitamins and minerals and all that kind of stuff. To me, Athletic Greens just makes that super easy because it covers all the bases for you. And, very importantly, it tastes delicious. Again, just like discipline is freedom, having a nutritional basis is a kind of freedom. You can fast all day, you can eat whatever crap you usually eat, and you're safe. At least you got the stuff that your body needs. They'll give you a one-month supply of fish oil when you sign up at athleticgreens.com slash lex. This is the Lex Friedman Podcast. To support it, please check out our sponsors in the description. And now, dear friends, here's John Carmack. 

John Carmack: 0:09:35

What was the first program you've ever written? What was the first program you've ever written? 

Lex 0:09:53

Do you remember? 

John Carmack: 0:09:54

Yeah, I do. So I remember being in a radio shack, going up to the TRS-80 computers and learning just enough to be able to do 10 print John Carmack. And it's kind of interesting how, of course, I, you know, Carnegan and Ritchie kind of standardized Hello World as the first thing that you do in every computer programming language in every computer, but not having any interaction with the cultures of Unix or any other standardized things, it was just like, well, what am I gonna say? I'm gonna say my name. And then you learn how to do GoTo10 and have it scroll all off the screen. And that was definitely the first thing that I wound up doing on a computer. 

Lex 0:10:32

Can I ask you a programming advice? I was always told in the beginning that you're not allowed to use GoTo statements. That's really bad programming. Is this correct or not? Jumping around code. Can we look at the philosophy and the technical aspects of the GoTo statement that seems so convenient, but it's supposed to be bad programming? 

John Carmack: 0:10:49

Well, so certainly back in the day in basic programming languages, you didn't have proper loops. You didn't have for whiles and repeats. You know, that was the land of Pascal for people that kind of generally had access to it back then. So you had no choice but to use GoTos. And as you made what were big programs back then, which were a thousand line basic program is a really big program. They did tend to sort of degenerate into madness. You didn't have good editors or code exploration tools. So you would wind up fixing things in one place, add a little patch. And there's reasons why structured programming generally helps understanding, but GoTos aren't poisonous. Sometimes they're the right thing to do. Usually it's because there's a language feature missing like nested breaks or something where it can sometimes be better to do a GoTo cleanup or GoTo error rather than having multiple flags, multiple if statements littered throughout things. But it is rare. I mean, if you grep through all of my code right now, I don't think any of my current code bases would actually have a GoTo, but deep within sort of the technical underpinnings of a major game engine, you're gonna have some GoTos in a couple of places probably. 

Lex 0:12:00

Yeah, the infrastructure on top of, like the closer you get to the machine code, the more GoTos you're gonna see, the more of these like hacks you're going to see because the set of features available to you in low level programming languages is limited. So print John Carmack, when is the first time, if we could talk about love, that you fell in love with programming? You said like, this is really something special. 

John Carmack: 0:12:27

It really was something that was one of those love at first sight things where just really from the time that I understood what a computer was, even, I mean, I remember looking through old encyclopedias at the black and white photos of the IBM mainframes with the reel-to-reel tape decks. And for people nowadays, it can be a little hard to understand what the world was like then from information gathering where I would go to the libraries and there would be a couple books on the shelf about computers and they would be very out of date even at that point, just not a lot of information, but I would grab everything that I could find and devour everything. Whenever Time or Newsweek had some article about computers, I would like cut it out with scissors and put it somewhere. It just, it felt like this magical thing to me, this idea that the computer would just do exactly what you told it to. I mean, and there's a little bit of the genie monkey's paw sort of issues there where you'd better be really, really careful with what you're telling it to do, but it wasn't gonna backtalk you. It wasn't gonna have a different point of view. It was gonna carry out what you told it to do. And if you had the right commands, you could make it do these pretty magical things. 

Lex 0:13:36

And so what kind of programs did you write at first? So beyond the print, John Carmack. 

John Carmack: 0:13:41

So I can remember as going through the learning process where you find at the start, you're just learning how to do the most basic possible things. And I can remember stuff like a Superman comic that Radio Shack commissioned to have, it's like Superman had lost some of his super brain and kids had to use Radio Shack TRS-80 computers to do calculations for it to help him kind of complete his heroics. And I'd find little things like that and then get a few basic books to be able to kind of work my way up. And again, it was so precious back then. I had a couple books that would teach me important things about it. I had one book that I could start to learn a little bit of assembly language from, and I'd have a few books on basic and some things that I could get from the libraries. But my goals in the early days was almost always making games of various kinds. I loved the arcade games and the early Atari 2600 games and being able to do some of those things myself on the computers was very much what I aspired to. And it was a whole journey where if you learn normal basic, you can't do any kind of an action game. You can write an adventure game. You can write things where you say, what do you do here? I get sword, attack, troll, that type of thing. And that can be done in the context of basic. But to do things that had moving graphics, there were only the most limited things you could possibly do. You could maybe do breakout or pong or that sort of thing in low resolution graphics. And in fact, one of my first sort of major technical hacks that I was kind of fond of was on the Apple II computers, they had a mode called low resolution graphics where of course all graphics were low resolution back then, but regular low resolution graphics, it was a grid of 40 by 40 pixels normally, but they could have 16 different colors. And I wanted to make a game kind of like the arcade game Vanguard, just a scrolling game. And I wanted to just kind of have it scroll vertically up and I could move a little ship around. You could manage to do that in basic, but there's no way you could redraw the whole screen. And I remember at the time just coming up with what felt like a brainstorm to me where I knew enough about the way the hardware was controlled where the text screen and the low resolution graphics screen were basically the same thing. And all those computers could scroll their text screen reasonably. You could do a listing and it would scroll things up. And I figured out that I could kind of tweak just a couple things that I barely understood to put it into a graphics mode and I could draw graphics. And then I could just do a line feed at the very bottom of the screen. And then the system would scroll it all up using an assembly language routine that I didn't know how to write back then. So that was like this first great hack that sort of had analogs later on in my career for a lot of different things. So I found out that I could draw a screen, I could do a line feed at the bottom, we would scroll it up once, I could draw a couple more lines of stuff at the bottom. And that was my first way to kind of scroll the screen, which was interesting in that that played a big part later on in the id software days as well. 

Lex 0:16:46

So do efficient drawing where you don't have to draw the whole screen, but you draw from the bottom using the thing that was designed in the hardware for text output. 

John Carmack: 0:16:57

Yeah, where so much of until recently, game design was limited by what you could actually get the computer to do, where it's easy to say like, okay, I want to scroll the screen. You just redraw the entire screen at a slight offset. And nowadays that works just fine. Computers are ludicrously fast. But up until a decade ago or so, there were all these things everybody wanted to do. But if they knew enough programming to be able to make it happen, it would happen too slow to be a good experience, either just ridiculously slow or just slow enough that it wasn't fun to experience it like that. So, so much of kind of the first couple decades of the programming work that I did was largely figuring out how to do something that everybody knows how they want it to happen. It just has to happen two to 10 times faster than sort of the straightforward way of doing things would make it happen. And it's different now because at this point, lots of things you can just do in the most naive possible way and it still works out. You don't have nearly the creative limitations or the incentives for optimizing on that level. And there's a lot of pros and cons to that. But I do generally, I'm not gonna do the angry old man shaking my fist at the clouds bit where back in my day, programmers had to do real programming. It's amazing that you can just kind of pick an idea and go do it right now. And you don't have to be some assembly language wizard or deep GPU arcanist to be able to figure out how to make your wishes happen. 

Lex 0:18:28

Well, there's still, see, that's true. But let me put on my old man with a fist hat and say that probably the thing that will define the future still requires you to operate at the limits of the current system. So we'll probably talk about this, but if you talk about building the metaverse and building a VR experience that's compelling, it probably requires you to not to go to assembly or maybe not literally, but sort of spiritually to go to the limits of what the system is capable of. 

John Carmack: 0:19:01

Yeah, and that really was why virtual reality was specifically interesting to me where it had all the ties to, you could say that even back in the early days, I have some old magazine articles that's talking about Doom as a virtual reality experience back when just seeing anything in 3D. So you could say that we've been trying to build those virtual experiences from the very beginning. And in the modern era of virtual reality, especially on the mobile side of things, when it's standalone, you're basically using a cell phone chip to be able to produce these very immersive experiences. It does require work. It's not at the level of what an old school console game programmer would have operated at where you're looking at hardware registers and you're scheduling all the DMA accesses, but it is still definitely a different level than what a web developer or even a PC Steam game developer usually has to work at. And again, it's great. There's opportunities for people that wanna operate at either end of that spectrum there and still provide a lot of value to the world. 

Lex 0:20:02

Let me ask you sort of a big question about preference. What would you say is the best programming language? Your favorite, but also the best. You've seen throughout your career, you're considered by many to be the greatest programmer ever. I mean, it's so difficult to place that label on anyone, but if you put it on anyone, it's you. So let me ask you these kind of ridiculous questions of what's the best band of all time. But in your case, what's the best programming language? 

John Carmack: 0:20:34

Everything has all the caveats about it. But so what I use, so nowadays I do program a reasonable amount of Python for AI ML sorts of work. I'm not a native Python programmer. It's something I came to very late in my career. I understand what it's good for. 

Lex 0:20:51

But you don't dream in Python. 

John Carmack: 0:20:53

I do not. And it has some of those things where there's some amazing stats when you say, if you just start, if you make a loop, you know, a triply nested loop and start doing operations in Python, you can be thousands to potentially a million times slower than a proper GPU tensor operation. And these are staggering numbers. You know, you can be as much slower as we've almost gotten faster in our pace of progress and all this other miraculous stuff. 

Lex 0:21:20

So your intuitions about inefficiencies within the Python sort of- 

John Carmack: 0:21:23

It keeps hitting me upside the face where it's gotten to the point now I understand. It's like, okay, you just can't do a loop if you care about performance in Python. You have to figure out how you can reformat this into some big vector operation or something that's going to be done completely within a C++ library. But the other hand is it's amazingly convenient. And you just see stuff that people are able to cobble together by, you just import a few different things and you can do stuff that nobody on earth could do 10 years ago. And you can do it in a little cookbook thing that you copy pasted out of a website. So that is really great. When I'm sitting down to do what I consider kind of serious programming, it's still in C++. And it's really kind of a C flavored C++ at that where I'm not big into the modern template meta programming sorts of things. I see a lot of train wrecks coming from some of that over abstraction. I spent a few years really going kind of deep into the kind of the historical Lisp work and Haskell and some of the functional programming sides of things. And there is a lot of value there in the way you think about things. And I changed a lot of the way I write my C and C++ code based on what I learned about the value that comes out of not having this random mutable state that you kind of lose track of. Because something that many people don't really appreciate till they've been at it for a long time is that it's not the writing of the program initially, it's the whole lifespan of the program. And that's when it's not necessarily just how fast you wrote it or how fast it operates, but it's how can it bend and adapt as situations change. And then the thing that I've really been learning in my time at Meta with the Oculus and VR work is it's also how well it hands off between a continuous kind of revolving door of programmers taking over maintenance and different things and how you get people up to speed in different areas. And there's all these other different aspects of it. 

Lex 0:23:20

So- Is C++ a good language for handover between engineers? 

John Carmack: 0:23:25

Probably not the best. And there's some really interesting aspects to this where in some cases, languages that are not, that are not generally thought well of for many reasons, like C is derided pretty broadly that yes, obviously all of these security flaws that happen with the memory and unsafeness and buffer overruns and the things that you've got there, but there is this underappreciated aspect to the language is so simple, anyone can go and if you know C, you can generally jump in someplace and not have to learn what paradigms they're using because there just aren't that many available. I think there's, you know, and there's some really, really well-written C code. Like it's, I find it great that if I'm messing around with something in OpenBSD say, I mean, I can be walking around in the kernel and I'm like, I understand everything that's going on here. It's not hard for me to figure out what's I, you know, what I need to do to, you know, make whatever change that I need to. While you can have, you know, more significant languages, like it's a downside of Lisp where I don't regret the time that I spent with Lisp. I think that it did help, you know, help my thinking about programming in some ways. But the people that are the biggest defenders of Lisp are saying how malleable of a language it is that if you write a huge Lisp program, you've basically invented your own kind of language and structure because it's not the primitives of the language you're using very much. It's all of the things you've built on top of that. And then a language like Racket, kind of one of the more modern Lisp versions, it's essentially touted as a language for building other languages. And I understand the value of that for a tiny little project, but the idea of that for one of these long-term supported by lots of people kind of horrifies me where all of those abstractions that you're like, okay, you can't touch this code till you educate yourself on all of these things that we've built on top of that. And it was interesting to see how when Google made Go, a lot of the criticisms of that are it's like, wow, this is not a state-of-the-art language. This language is just so simple and almost crude. And you could see the programming language people just looking down at it. But it does seem to be quite popular as basically saying this is the good things about C. Everybody can just jump right in and use it. You don't need to restructure your brain to write good code in it. So I wish that I had more opportunity for doing some work in Go. Rust is the other modern language that everybody talks about that I'm not fit to pass judgment on. I've done a little bit beyond Hello World. I wrote some like video decompression work in Rust just as an exercise, but that was a few years ago and I haven't really used it since. The best programming language is the one that works generally that you're currently using because that's another trap is in almost every case I've seen when people mixed languages on a project, that's a mistake. I would rather stay just in one language so that everybody can work across the entire thing. And we have, I get meta, we have a lot of projects that use kind of React framework. So you've got JavaScript here and then you have C++ for real work. And then you may have Java interfacing with some other part of the Android system. And those are all kind of horrible things. And that was one thing that I remember talking with Boz at Facebook about it, where like, man, I wish we could have just said, we're only hiring C++ programmers. And he just thought from the Facebook meta perspective, well, we just wouldn't be able to find enough. With the thousands of programmers they've got there, it is not necessarily a dying breed, but you can sure find a lot more Java or JavaScript programmers. And I kind of mentioned that to Elon one time and he was kind of flabbergasted about that. It's like, well, you just, you go out and you find those programmers and you don't hire the other programmers that don't do the languages that you want to use. But right now, I guess, yeah, they're using JavaScript on a bunch of the SpaceX work for the UI side of things. When you go find UI programmers, they're JavaScript programmers. 

Lex 0:27:30

I wonder if that's because there's a lot of JavaScript programmers, because I do think that great programmers are rare. That it's not, you know, if you just look at statistics of how many people are using different programming languages that doesn't tell you the story of what the great programmers are using. And so you have to really look at what you were speaking to, which is the fundamentals of a language. What does it encourage? How does it encourage you to think? What kind of systems does it encourage you to build? There is something about C++ that has elements of creativity, but forces you to be an adult about your programming. 

John Carmack: 0:28:08

Which is- It expects you to be an adult. It expects you to. It does not force you to. 

Lex 0:28:11

And so it brings out people that are willing to be creative in terms of building large systems and coming up with interesting solutions, but at the same time have the, sort of the good software engineering practices that amend themselves to real world systems. Let me ask you about this other language, JavaScript. So if we, you know, aliens visit in thousands of years and humans are long gone, something tells me that most of the systems they find will be running JavaScript. I kind of think that if the simul- If we're living in a simulation, it's written in JavaScript. You know, for the longest time, even still, JavaScript didn't get any respect and yet it runs so much of the world and an increasing number of the world. Is it possible that all, everything will be written in JavaScript one day? 

John Carmack: 0:29:09

So the engineering under JavaScript is really pretty phenomenal. The systems that make JavaScript run as fast as it does right now are kind of miracles of modern engineering in many ways. It does feel like it is not an optimal language for all the things that it's being used for or an optimal distribution system to build huge apps in something like this without type systems and so on. But I think for a lot of people, it does reasonably the necessary things. It's still a C-flavored language. It's still a braces and semicolon language. It's not hard for people to be trained in JavaScript and then understand the roots of where it came from. I think garbage collection is unequivocally a good thing for most programs to be written in. It's funny that I still, just this morning, I was on, I was seeing a Twitter thread of a bunch of really senior game dev people arguing about the virtues and costs of garbage collection. And you will run into some people that are top-notch programmers that just say, no, this is literally not a good thing. 

Lex 0:30:17

Oh, because it makes you lazy? 

John Carmack: 0:30:18

Yes, that it makes you not think about things. And I do disagree. I think that there is so much objective data on the vulnerabilities that have happened in C and C++ programs, sometimes written by the best programmers in the world. It's like nobody is good enough to avoid ever shooting themselves in the foot with that. You write enough C code, you're going to shoot yourself in the foot. And garbage collection is a very great thing for the vast majority of programs. It's only when you get into the tightest of real-time things that you start saying, it's like, no, the garbage collection has more costs than it has benefits for me there. But that's not 99 plus percent of all the software in the world. So JavaScript is not terrible in those ways. And so much of programming is not the language itself. It's the infrastructure around everyone that surrounds it, all the libraries that you can get and the different stuff that you can, ways you can deploy it, the portability that it gives you. And JavaScript is really strong on a lot of those things where for a long time, and it still does if I look at it, but the web stack about everything that has to go when you do something really trivial in JavaScript and it shows up on a web browser to kind of X-ray through that and see everything that has to happen for your one little JavaScript statement to turn into something visible in your web browser. It's very, very disquieting, just the depth of that stack and the fact that so few people can even comprehend all of the levels that are going on there. But it's again, I have to caution myself to not be the in the good old days old man about it because clearly there's enormous value here. The world does run on JavaScript to a pretty good approximation there and it's not falling apart. There's a bunch of scary stuff where you look at console logs and you just see all of these bad things that are happening, but it's still kind of limping along and nobody really notices. But so much of my systems design and systems analysis goes around, you should understand what the speed of light is, like what would be the best you could possibly do here. And it sounds horrible, but in a lot of cases, you can be a thousand times off your speed of light, velocity for something and it's still be okay. And in fact, it can even sometimes still be the optimal thing in a larger system standpoint where there's a lot of things that you don't wanna have to parachute in someone like me to go in and say, make this webpage run a thousand times faster, make this web app into a hardcore native application that starts up in 37 milliseconds and everything responds in less than one frame latency. That's just not necessary. And if somebody wants to go pay me millions of dollars to do software like that, when they can take somebody right out of a bootcamp and say, spin up an application for this, often being efficient is not really the best metric. And it's like, that applies in a lot of areas where it's kind of interesting how a lot of our appliances and everything are all built around energy efficiency, sometimes at the expense of robustness in some other ways or higher costs in other ways, where there's interesting things where energy or electricity could become much cheaper in a future world. And that could change our engineering trade-offs for the way we build certain things where you could throw away efficiency and actually get more benefits that actually matter. I mean, that's one of my, one of the directions I was considering swerving into was nuclear energy. When I was kind of like, what do I want to do next? It was either going to be cost-effective nuclear fission or artificial general intelligence. And one of my pet ideas there is like, people don't understand how cheap nuclear fuel is. And there would be ways that you could be a quarter the efficiency or less, but if it wound up making your plant 10 times cheaper, that could be a radical innovation in something like that. So there's like some of these thoughts around like direct fission energy conversion, fission fragment conversion that, maybe you build something that doesn't require all the steam turbines and everything, even if it winds up being less efficient. So that applies a lot in programming where there's always, it's always good to know what you could do if you really sat down and took it far, because sometimes there's discontinuities like around user reaction times, there are some points where the difference between operating in one second and 750 milliseconds, not that huge. You'll see it in webpage statistics, but most of the usability stuff, not that great. But if you get down to 50 milliseconds, then all of a sudden this just feels amazing. It's just like doing your bidding instantly rather than you're giving it a command, twiddling your thumbs, waiting for it to respond. So sometimes it's important to really crunch hard to get over some threshold, but there are broad basins in the value metric for lots of work where it just doesn't pay to even go that extra mile. And there are craftsmen that, they just don't wanna buy that and more power to them. If somebody just wants to say, no, I'm going to be, my pride is in my work, I'm never going to do something that's not as good as I could possibly make it. I respect that and sometimes I am that person, but I try to focus more on the larger value picture and you do pick your battles and you deploy your resources into play that's going to give you sort of the best user value in the end. 

Lex 0:35:53

Well, if you look at the evolution of life on earth as a kind of programming effort, it seems like efficiency isn't the thing that's being optimized for. Like natural selection is very inefficient, but it kind of adapts and through the process of adaptations building more and more complex systems that are more and more intelligent, the final result is kind of pretty interesting. And so I think of JavaScript the same way. It's like this giant mess that, things naturally die off if they don't work and if they're become useful to people, they kind of naturally live. And then you build this community, large community of people that are generating code and some code is sticky, some is not. And nobody knows the inefficiencies or the breaking points, like how reliable this code is. And you kind of just run it, assume it works and then get unpleasantly surprised. And then that's very kind of the evolutionary process. 

John Carmack: 0:36:56

So that's a really good analogy and we can go a lot of places with that where in the earliest days of programming, when you had finite, you could count the bytes that you had to work on this. You had all the kind of hackers playing code golf to be one less instruction than the other person's multiply routine to kind of get through. And it was so perfectly crafted. It was a crystal piece of artwork when you had a program because there just were not that many, you couldn't afford to be lazy in different ways. And in many ways, I see that as akin to the symbolic AI work where again, if you did not have the resources to just say, well, we're gonna do billions and billions of programmable weights here, you have to turn it down into something that is symbolic and crafted like that. But that's definitely not the way DNA and life and biological evolution and things work. I, you know, on the one hand, it's almost humbling how little programming code is in our bodies. You know, we've got a couple of billion base pairs and it's like this all fits on a thumb drive for years now. And then our brains are even a smaller section of that. You've got maybe 50 megabytes. And this is not like Shannon limit, perfectly information dense conveyances here. It's like, these are messy codes. You know, they're broken up into amino acids. A lot of them don't do important things or they do things in very awkward ways, but it is this process of just accumulation on top of things. And you need scale, both you need scale for sort of the population for that to work out. And in the early days, in the 50s and 60s, the kind of ancient era of computers where you could count when they say, like when the internet started, even in the 70s, there were like 18 hosts or something on it. It was this small finite number and you were still optimizing everything to be as good as you possibly could be. But now it's billions and billions of devices and everything going on. And you can have this very much natural evolution going on where lots of things are tried. Lots of things are blowing up. Venture capitalists lose their money when a startup invested in the wrong tech stack and things completely failed or failed to scale. But good things do come out of it. And it's interesting to see the mimetic evolution of the way different things happen. Like mentioning Hello World at the beginning. It's funny how some little thing like that where every programmer knows Hello World now, and that was a completely arbitrary sort of decision that just came out of the dominance of Unix and C and early examples of things like that. So millions of experiments are going on all the time, but some things do kind of rise to the top and win the fitness war for whether it's Mindspace or programming techniques or anything. 

Lex 0:39:43

Like there's a site on Stack Exchange called Code Golf where people compete to write the shortest possible program for a particular task in all the different kinds of languages. And it's really interesting to see folks kind of that are masters of their craft really play with the limits of programming languages. It's really beautiful to see. And across all the different programming languages, you get to see some of these weird programming languages and mainstream ones, difference between Python 2 and 3. You get to see the difference between C and C++ and Java, and you get to see JavaScript, all of that. And it's kind of inspiring to see how much depth of possibility there is within programming languages that Code Golf kind of tasks reveal. Most of us, if you do any kind of programming, you kind of do boring kind of very vanilla type of code. That's the way to build large systems, but it's nice to see that the possibility of creative genius is still within those languages. It's laden within those languages. So given that you are, once again, one of the greatest programmers ever, what do you think makes a good programmer? Maybe a good modern programmer. 

John Carmack: 0:41:04

So I just gave a long rant slash lecture at Meta to the TPM organization. And my biggest point was everything that we're doing really should flow from user value. All the good things that we're doing. It's like, we're not technical people. It's like, you shouldn't be taking pride just in the specific thing. Like Code Golf is the sort of thing, it's a fun puzzle game, but that really should not be a major motivator for you. It's like, we're solving problems for people or we're providing entertainment to people. We're doing something of value to people that's displacing something else in their life. So we want to be providing a net value over what they could be doing, but instead they're choosing to use our products. And that's where, I mean, it sounds trite or corny, but I fundamentally do think that's how you make the world a better place. If you have given more value to people than it took you and your team to create, then the world's a better place. People have, they've gone from something of lesser value, chosen to use your product and their life feels better for that. And if you've produced that economically, that's a really good thing. On the other hand, if you spent ridiculous amounts of money, you've just kind of shoveled a lot of cash into a wood chipper there and you should maybe not feel so good about what you're doing. So being proud about like a specific architecture or a specific technology or a specific code sequence that you've done, it's great to get a little smile, like a tiny little dopamine hit for that, but the top level metric should be that you're building things of value. Now you can get into the argument about how you, what is user value? How do you actually quantify that? And there can be big arguments about that, but it's easy to be able to say, okay, this pissed off user there is not getting value from what you're doing. This user over there with the big smile on their face, I am the moment of delight when something happened. There's a value that's happened there. I mean, if you, you have to at least accept that there is a concept of user value, even if you have trouble exactly quantifying it, you can usually make relative arguments about it. Well, this was better than this. We've improved things. So, being a servant to the user is your job when you're a developer. You want to be producing something that, other people are going to find valuable. And if you are technically inclined, then finding the right levers to be able to pull, to be able to make a design that's going to produce the most value for the least amount of effort. And it always has to be kind of divided. There's a ratio there where you, it's a problem at the big tech companies, whether it's MetaGoogle, Apple, Microsoft, Amazon, companies that have almost infinite money. I mean, I know their CFO will complain that it's not infinite money, but from most developers' standpoints, it really does feel like it. And it's almost counterintuitive that if you're working hard as a developer on something, there's always this thought, if only I had more resources, more people, more RAM, more megahertz, then my product will be better. And that sense that at certain points, it's certainly true that if you are really hamstrung by this, removing an obstacle will make a better product, make more value. But if you're not making your core design decisions in this fiercely competitive way, where you're saying feature A or feature B, you can't just say, let's do both, because then you're not making a value judgment about them. You're just saying, well, they both seem good. I don't want to necessarily have to pick out which one is better or how much better and tell team B that, sorry, we're not going to do this because A is more important. But that notion of always having to really critically value what you're doing, your time, the resources you expend, even the opportunity cost of doing something else, that's super important. Well, let me ask you about this, 

Lex 0:44:59

the big debates that you're mentioning of how to measure value. Is it possible to measure it kind of numerically, or can you do the sort of Johnny Ive, the designer route of imagining sort of somebody using a thing and imagining a smile on their face, imagining the experience of love and joy that you have when you use the thing? That's from a design perspective, or if you're building more like a lower level thing for like Linux, you imagine a developer that might come across this and use it and maybe it's a good idea to use it. Let's then use it and become happy and better off because of it. So where do you land on those things? Is it measurable? So I imagine like Meta and Google will probably try to measure the thing. They'll try to, it's like you try to optimize engagement or something, let's measure engagement. And then I think there is a kind of, I mean, I admire the designer ethic of like, think of a future that's immeasurable. And you try to make somebody in that future that's different from today happy. 

John Carmack: 0:46:10

So I do usually favor, if you can get any kind of a metric that's good, by all means, listen to the data, but you can go too far there where we've had problems where it's like, hey, we had a performance regression because our fancy new telemetry system is doing a bazillion file writes to kind of archive this stuff because we needed to collect information to determine if we were doing, if our plans were good. So when information is available, you should never ignore it. I mean, all of it- 

Lex 0:46:40

From actual users using the thing, human beings using the thing, large number of human beings, 

John Carmack: 0:46:46

and you get to see sort of at low of large numbers. So there's the zero to one problem of when you're doing something really new, you do kind of have to make a guess. But one of the points that I've been making at Meta is we have more than enough users now that anything somebody wants to try in VR, we have users that will be interested in that. You do not get to make a completely green field, blue sky pitch and say, I'm going to do this because I think it might be interesting. I challenge everyone. There are going to be people, whether it's working in VR on your, like on your desktop replacement or communicating with people in different ways 

Lex 0:47:22

or playing the games. 

John Carmack: 0:47:24

There are going to be probably millions of people, or at least if you pick some tiny niche that we're not in right now, there's still going to be thousands of people out there that have the headsets that would be your target market. And I tell people, pay attention to them. Don't invent fictional users. Don't make an Alice, Bob, Charlie that fits whatever matrix of tendencies that you want to break the market down to because it's a mistake to think about imaginary users when you've got real users that you could be working with. But on the other hand, there is value to having a kind of wholeness of vision for a product. And companies like Meta have, they understand the trade-offs where you can have a company like SpaceX or Apple in the Steve Jobs era where you have a very powerful leading personality that can micromanage at a very low level and can say, it's like, no, that handle needs to be different or that icon needs to change the tint there. And they clearly get a lot of value out of it. They also burn through a lot of employees that have horror stories to tell about working there afterwards. My position is that you're at your best when you've got a leader that is at their limit of what they can kind of comprehend of everything below them. And they can have an informed opinion about everything that's going on. And you take somebody, you've got to believe that somebody that has 30, 40 years of experience, you would hope that they've got wisdom that the just out of bootcamp person contributing doesn't have. And that if they're like, well, that's wrong there, you probably shouldn't do it that way or even just don't do it that way, do it another way. So there's value there, but it can't go beyond a certain level. I mean, I have Steve Jobs stories of him saying things that are just wrong right in front of me about technical things because he was not operating at that level. But when it does work and you do get that kind of passionate leader that's thinking about the entire product and just really deeply cares about not letting anything slip through the cracks, I think that's got a lot of value. But the other side of that is the people saying that, well, we want to have these independent teams that are bubbling up the ideas because it's almost it's anti-capitalist or anti-free market to say, it's like I want my great leader to go ahead and dictate all these points there where clearly free markets bring up things that you don't expect. Like in VR, we saw a bunch of things, like it didn't turn out at all the way the early people thought were going to be the key applications and things that would not have been approved by the dark cabal making the decisions about what gets into the store turned out to in some cases be extremely successful. So yeah, I definitely kind of wanted to be there as a point where I did make a pitch. It's like, hey, make me VR dictator and I'll go in and get shit done. And that's just, it's not in the culture at Meta. And they understand the trade-offs and that's just not the way, that's not the company that they want, the team that they want to do. 

Lex 0:50:30

It's fascinating because VR, and we'll talk about it more, it's still unclear to me in what way VR will change the world because it does seem clear that VR will somehow fundamentally transform this world. And it's unclear to me how. Yeah. 

John Carmack: 0:50:47

Let me know when you want to get into that. We will, but hold on a second. 

Lex 0:50:51

So stick to you being the best programmer ever. Okay, in the early days when you didn't have adult responsibilities of leading teams and all that kind of stuff, and you can focus on just being a programmer, what did a productive day in the life of John Carmack look like? How many hours of the keyboard? How much sleep? What was the source of calories that fueled the brain? What was it like? What time did you wake up? 

John Carmack: 0:51:20

So I was able to be remarkably consistent about what was good working conditions for me for a very long time. I was never one of the programmers that would do all-nighters going through, work for 20 hours straight. It's like my brain generally starts turning to mush after 12 hours or so. But the hard work is really important. And I would work for decades. I would work 60 hours a week. I would work a 10-hour day, six days a week, and try to be productive at that. Now, my schedule shifted around a fair amount. When I was young, without any kids, I and any other responsibilities, I was on one of those cycling schedules where I'd kind of get in an hour later each day and roll around through the entire time. And I'd wind up kind of pulling in at two or three in the afternoon sometimes, and then working again past midnight or two in the morning. And that was, when it was just me trying to make things happen, and I was usually isolated off in my office, people generally didn't bother me much at in, and I could get a lot of programming work done that way. I did settle into a more normal schedule when I was taking kids to school and things like that. 

Lex 0:52:33

So kids were the forcing function that got you to wake up at the same time each day. 

John Carmack: 0:52:37

It's not clear to me that there was much of a difference in the productivity with that, where I kind of feel, if I just get up when I feel like it, it's usually a little later each day, but I just recently made the focusing decision to try to push my schedule back a little bit earlier to getting up at eight in the morning and trying to shift things around. Like I'm often doing experiments with myself about what should I be doing to be more productive. And one of the things that I did realize was happening in recent months, where I would go for a walk or a run, I cover like four miles a day, and I would usually do that just as the sun's going down. And here in Texas now, and it's still really damn hot, but I'd go out at 8.30 or something and cover the time there and then the showering. And it was putting a hole in my day where I would have still a couple hours after that. And sometimes my best hours were at night when nobody else is around, nobody's bothering me. But that hole in the day was a problem. So just a couple of weeks ago, I made the change to go ahead and say, all right, I'm gonna get up a little earlier. I'm gonna do a walk or get out there first so I can have more uninterrupted time. So I'm still playing with factors like this as I kind of optimize my work efforts. But it's always been, it was 60 hours a week for a very long time. To some degree, I had a little thing in the back of my head where I was almost jealous of some of the programmers that would do these marathon sessions. And I had like Dave Taylor, one of the guys that he had, he would be one of those people that would fall asleep under his desk sometimes, and all the kind of classic hacker tropes about things. And a part of me was like, always a little bothered that that wasn't me, that I wouldn't go program 20 hours straight because I'm falling apart and not being very effective after 12 hours. I mean, yeah, 12-hour programming, that's fine when you're doing that, but you're not doing smart work much after, at least I'm not, but there's a range of people. I mean, that's something that a lot of people don't really get in their gut, where there are people that work on four hours of sleep and are smart and can continue to do good work, but then there's a lot of people that just fall apart. So I do tell people that I always try to get eight hours of sleep. It's not this, you know, push yourself harder, get up earlier, I just do worse work, where, you know, you can work 100 hours a week and still get eight hours of sleep if you just kind of prioritize things correctly. But I do believe in working hard, working a lot. There was a comment that a game dev made that I know there's a backlash against really hard work in a lot of cases, and I get into online arguments about this all the time, but he was basically saying, yeah, 40 hours a week, that's kind of a part-time job. And if you are really in it, you're doing what you think is important, what you're passionate about, working more gets more done. And it's just really not possible to argue with that if you've been around the people that work with that level of intensity and just say, it's like, no, they should just stop. And we had, I kind of came back around to that 

Lex 0:55:42

a couple of years ago, 

John Carmack: 0:55:43

where I was using the fictional example of, all right, some people say, they'll say with a straight face, they think, no, you are less productive if you work more than 40 hours a week. And they're generally misinterpreting things where your marginal productivity for an hour after eight hours is less than in one of your peak hours, but you're not literally getting less done. There is a point where you start breaking things and getting worse behavior and everything out of it, where you're literally going backwards, but it's not at eight or 10 or 12 hours. And the fictional example I would use was, imagine there's an asteroid coming to impact, to crash into earth, destroy all of human life. Do you want Elon Musk or the people working at SpaceX that are building the interceptor that's going to deflect the asteroid, do you want them to clock out at five? Because dammit, they're just gonna go do worse work if they work another couple hours. And it seems absurd. And that's a hypothetical though, and everyone can dismiss that. But then when coronavirus was hitting and you have all of these medical personnel that are clearly pushing themselves really, really hard, and I'd say, it's like, okay, do you want all of these scientists working on treatments and vaccines and caring for all of these people? Are they really screwing everything up by working more than eight hours a day? And of course people say, I'm just an asshole to say something like that, but it's, I know, it's the truth. Working longer gets more done. 

Lex 0:57:10

Well, so that's kind of the layer one, but I'd like to also say that, at least I believe, depending on the person, depending on the task, working more and harder will make you better for the next week in those peak hours. So there's something about a deep dedication to a thing that kind of gets deep in you. So the hard work isn't just about the raw hours of productivity, it's the thing it does to you in the weeks and months after too. 

John Carmack: 0:57:49

You're tempering yourself in some ways. 

Lex 0:57:52

And I think, it's like your zero germs of sushi. If you really dedicate yourself completely to making the sushi, like to really putting in the long hours, day after day after day, you become a true craftsman of the thing you're doing. Now there's of course, discussions about, are you sacrificing a lot of personal relationships? Are you sacrificing a lot of other possible things you could do with that time? But if you're talking about purely being a master or a craftsman of your art, that more hours isn't just about doing more, it's about becoming better at the thing you're doing. 

John Carmack: 0:58:30

Yeah, and I don't gainsay anybody that wants to work the minimum amount. They've got other priorities in their life. My only argument that I'm making, it's not that everybody should work hard. It's that if you want to accomplish something, working longer and harder is the path to getting it accomplished. 

Lex 0:58:46

Well, let me ask you about this then, the mythical work-life balance. For an engineer, it seems like that's one of the professions for programmer where working hard does lead to greater productivity in it, but it also raises the question of sort of personal relationships and all that kind of stuff, family. How were you able to find work-life balance? Is there advice you can give, maybe even outside of yourself? Have you been able to arrive at any wisdom on this part in your years of life? 

John Carmack: 0:59:25

I do think that there's a wide range of people where different people have different needs. It's not a one size fits all. Certainly what works for me, I can tell enough that I'm different than a typical average person in the way things impact me, the things that I want to do, my goals are different, and sort of the levers to impact things are different where I have literally never felt burnout. And I know there's lots of brilliant, smart people that do world-leading work that get burned out, and it's never hit me. 